function [c, ceq] = constraints(U, x0, M, A_bar, B_bar, N, robotShape, sys, ...
                    use_load, X_L_stacked, A_bar_load, B_bar_load, loadShape)
    
        % Obtain the number of vertices
    [~, L] = size(robotShape);
    
        % Obtain the number of states n and number of inputs m
    n = sys.n;

%% Obstacle avoidance
% c(x) = A_bar * x_h - B_bar s.t    c(x) <= 0

    if M >= 1
    
        x_pred = stateEvolution(U, x0, sys, N);
        c_obst_av = A_bar * x_pred - B_bar + sys.obs_margin*ones([size(B_bar,1), 1]);
        
        if use_load == true
            diff = x_pred - X_L_stacked;
            for i = 0:N - 1
                load_pred(i*n+1:i*n + 3, 1) = x_pred(i*n+1:i*n + 3, 1) + [Rmat(atan2(diff(i*n+2),diff(i*n+1)))*loadShape(:,1); 0];
            end
            
            c_load = A_bar_load(1:3*N,1:3*N) * load_pred - B_bar_load(1:3*N,1);
            c_obst_av(end+1:end+size(c_load, 1)) = c_load;
        end

    else % If there are no constraints
        c_obst_av = [];
    end

%% Input constraints
% Defined in the fmincon function

%% Final output

    c = c_obst_av;
    ceq = [];

end